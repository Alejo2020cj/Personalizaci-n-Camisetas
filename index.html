<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DiseÃ±ador Cyberpunk de Camisetas</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
<style>
  :root{ --neon1:#ff00cc; --neon2:#00e5ff; --bg:#04040a; }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh;
    background:radial-gradient(circle at top left,var(--bg),#0b0b12);
    color:#fff; font-family:'Orbitron',sans-serif;
    display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px;
  }
  header{
    width:100%; text-align:center; padding:14px;
    background:linear-gradient(90deg,var(--neon1),var(--neon2));
    box-shadow:0 6px 30px rgba(0,0,0,0.4); border-radius:8px; font-size:1.2rem;
  }
  .controls{ width:100%; max-width:1000px; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; padding:8px; }
  .controls > * { min-width:120px; }
  button, .file-label{
    background: linear-gradient(90deg,var(--neon1),var(--neon2));
    color:#000; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700; box-shadow:0 8px 20px rgba(0,0,0,0.35);
    text-align:center;
  }
  input[type="file"]{ display:none; }
  .file-label{ display:inline-block; }
  .canvas-wrap{ width:100%; max-width:900px; display:flex; justify-content:center; align-items:center; }
  canvas{
    width:100%; height:auto; max-height:78vh; border-radius:12px;
    border:2px solid rgba(0,229,255,0.12); box-shadow:0 10px 40px rgba(0,0,0,0.6); background:#0b0b0b; touch-action:none;
  }
  .hint{ color:#cfe9ff88; font-size:0.9rem; text-align:center; max-width:900px; }
  @media (max-width:540px){ .controls > * { min-width: 48%; } .controls { gap:8px; } }
</style>
</head>
<body>
  <header>ğŸ‘• DiseÃ±ador Cyberpunk â€” Personaliza tu Camiseta</header>

  <div class="controls">
    <button id="btnEllas">ğŸ‘š Ellas</button>
    <button id="btnEllos">ğŸ‘• Ellos</button>

    <label class="file-label" for="mockupInput">ğŸ“¤ Subir mockup</label>
    <input id="mockupInput" type="file" accept="image/*">

    <label class="file-label" for="artInput">ğŸ–¼ï¸ Subir diseÃ±o</label>
    <input id="artInput" type="file" accept="image/*">

    <button id="downloadBtn">â¬‡ï¸ Descargar PNG</button>
    <button id="resetBtn">â†º Reiniciar</button>
  </div>

  <div class="canvas-wrap"><canvas id="canvas"></canvas></div>
  <div class="hint">Toca/arrastra para mover. Arrastra cualquier borde o esquina para redimensionar. Compatible PC y mÃ³vil.</div>

<script>
/* ============================
   CONFIGuraciÃ³n
   ============================ */
const DEFAULT_ELLAS = 'mockup_ellas';
const DEFAULT_ELLOS = 'mockup_ellos';

/* ============================
   DOM
   ============================ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const btnEllas = document.getElementById('btnEllas');
const btnEllos = document.getElementById('btnEllos');
const mockupInput = document.getElementById('mockupInput');
const artInput = document.getElementById('artInput');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');

const DPR = window.devicePixelRatio || 1;
const HANDLE = 20;
const MIN_SIZE = 30;

/* ============================
   Estado
   ============================ */
let mockupImg = null;
let artImg = null;
let art = { x: 100, y: 150, w: 300, h: 300 };

let pointerDown = false;
let activePointerId = null;
let dragging = false;
let resizing = false;
let resizeDir = null;
let dragOffset = { x: 0, y: 0 };

/* =====================================================
   PRECARGA SUTILE: cargamos en background las dos imÃ¡genes
   Esto NO cambia tu UI ni botones; solo evita la decodificaciÃ³n
   en el momento del click (soluciona congelamiento en mÃ³viles).
   ===================================================== */
const preloaded = {}; // mapa baseName -> HTMLImageElement

function preloadMockup(baseName) {
  // si ya precargada, OK
  if (preloaded[baseName]) return;
  const img = new Image();
  img.crossOrigin = "anonymous";
  // usar decoding async para hints
  img.decoding = "async";
  img.src = `${baseName}.png`; // intentamos png primero; loadDefaultMockup tambiÃ©n probarÃ¡ jpg/jpeg
  // no forzamos decode aquÃ­ (dejamos que browser haga lo que pueda),
  // pero tener la src ya puesta ayuda mucho en mÃ³viles porque empieza la descarga/decodificaciÃ³n.
  preloaded[baseName] = img;
}

// precargar al inicio (no rompe nada si archivos no existen)
preloadMockup(DEFAULT_ELLAS);
preloadMockup(DEFAULT_ELLOS);

/* =====================================================
   â›” FIX IMPORTANTE: loadDefaultMockup mejorada (usa preloaded si posible)
   - intenta png/jpg/jpeg
   - usa decoding="async" y img.decode() + requestAnimationFrame para no bloquear UI
   - no cambia nombres de variables ni flujo original
   ===================================================== */
function loadDefaultMockup(baseName){
  const exts = ['png','jpg','jpeg'];
  let i = 0;

  async function tryLoad(){
    if (i >= exts.length){
      alert("No se encontrÃ³ "+baseName+".png/.jpg/.jpeg");
      return;
    }

    // Si ya preparamos una imagen con baseName.png y estamos en la primera extensiÃ³n png,
    // usar esa referencia si estÃ¡ cargando o cargada.
    if (i === 0 && preloaded[baseName] && preloaded[baseName].src) {
      const pre = preloaded[baseName];
      // si ya cargÃ³ completamente, Ãºsala directamente
      if (pre.complete && pre.naturalWidth) {
        mockupImg = pre;
        setCanvasSizeToImage(pre);
        draw();
        return;
      }
      // si no estÃ¡ completa, intentar esperar su onload + decode para no bloquear
      try {
        pre.onload = async () => {
          try { await pre.decode(); } catch(e){ /* ignore */ }
          requestAnimationFrame(()=>{
            mockupImg = pre;
            setCanvasSizeToImage(pre);
            draw();
          });
        };
        // si ya empezÃ³, no hacer nada mÃ¡s; onload lo manejarÃ¡
        return;
      } catch(err){
        // en caso de fallo, caemos en el flujo normal
      }
    }

    // flujo normal: crear nuevo Image y probar extensiones
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.decoding = "async";
    img.onload = async () => {
      try { await img.decode(); } catch(e){ /* si falla decode seguimos */ }
      requestAnimationFrame(()=>{
        mockupImg = img;
        setCanvasSizeToImage(img);
        draw();
      });
    };
    img.onerror = () => { i++; tryLoad(); };
    img.src = `${baseName}.${exts[i]}`;
  }

  tryLoad();
}

/* =====================================================
   El resto del cÃ³digo se mantiene exactamente igual
   (no modifiquÃ© lÃ³gica de eventos, dibujo ni comportamiento)
   ===================================================== */

function setCanvasSizeToImage(img){
  const dpr = DPR;
  canvas.width = img.width * dpr;
  canvas.height = img.height * dpr;
  canvas.style.width = Math.min(img.width, window.innerWidth - 40) + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (mockupImg) {
    ctx.drawImage(mockupImg, 0, 0, canvas.width / DPR, canvas.height / DPR);
  } else {
    ctx.fillStyle = '#0b0b0b';
    ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
  }

  if (artImg) ctx.drawImage(artImg, art.x, art.y, art.w, art.h);

  if (artImg && (dragging || resizing || pointerDown)) {
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(art.x, art.y, art.w, art.h);

    ctx.fillStyle = '#ff00cc';
    ctx.fillRect(art.x + art.w - HANDLE/2, art.y + art.h - HANDLE/2, HANDLE, HANDLE);
  }
}

function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX ?? e.touches?.[0]?.clientX) - rect.left;
  const y = (e.clientY ?? e.touches?.[0]?.clientY) - rect.top;
  return {
    x: x * (canvas.width / rect.width) / DPR,
    y: y * (canvas.height / rect.height) / DPR
  };
}

function isInsideArt(p){
  return p.x >= art.x && p.x <= art.x + art.w && p.y >= art.y && p.y <= art.y + art.h;
}
function getResizeDirection(p){
  const nearLeft = Math.abs(p.x - art.x) < HANDLE;
  const nearRight = Math.abs(p.x - (art.x + art.w)) < HANDLE;
  const nearTop = Math.abs(p.y - art.y) < HANDLE;
  const nearBottom = Math.abs(p.y - (art.y + art.h)) < HANDLE;
  if (nearTop && nearLeft) return 'nw';
  if (nearTop && nearRight) return 'ne';
  if (nearBottom && nearLeft) return 'sw';
  if (nearBottom && nearRight) return 'se';
  if (nearTop) return 'n';
  if (nearBottom) return 's';
  if (nearLeft) return 'w';
  if (nearRight) return 'e';
  return null;
}

canvas.addEventListener('pointerdown', e => {
  e.preventDefault();
  if (activePointerId && activePointerId !== e.pointerId) return;
  activePointerId = e.pointerId;
  canvas.setPointerCapture(activePointerId);

  pointerDown = true;
  const pos = getPointerPos(e);
  const dir = getResizeDirection(pos);

  if (artImg && dir){
    resizing = true; resizeDir = dir;
  } else if (artImg && isInsideArt(pos)){
    dragging = true;
    dragOffset.x = pos.x - art.x;
    dragOffset.y = pos.y - art.y;
  }

  draw();
});

canvas.addEventListener('pointermove', e => {
  const pos = getPointerPos(e);
  const dir = getResizeDirection(pos);

  if (dir) canvas.style.cursor = dir + '-resize';
  else if (artImg && isInsideArt(pos)) canvas.style.cursor = 'move';
  else canvas.style.cursor = 'default';

  if (!pointerDown || activePointerId !== e.pointerId) return;

  e.preventDefault();
  if (dragging){
    art.x = pos.x - dragOffset.x;
    art.y = pos.y - dragOffset.y;
  } else if (resizing){
    const dx = pos.x - art.x;
    const dy = pos.y - art.y;
    switch (resizeDir){
      case 'n': art.h += art.y - pos.y; art.y = pos.y; break;
      case 's': art.h = dy; break;
      case 'w': art.w += art.x - pos.x; art.x = pos.x; break;
      case 'e': art.w = dx; break;
      case 'nw': art.w += art.x - pos.x; art.h += art.y - pos.y; art.x = pos.x; art.y = pos.y; break;
      case 'ne': art.w = dx; art.h += art.y - pos.y; art.y = pos.y; break;
      case 'sw': art.w += art.x - pos.x; art.x = pos.x; art.h = dy; break;
      case 'se': art.w = dx; art.h = dy; break;
    }
    if (art.w < MIN_SIZE) art.w = MIN_SIZE;
    if (art.h < MIN_SIZE) art.h = MIN_SIZE;
  }

  draw();
});

function endPointer(e){
  if (activePointerId !== e.pointerId) return;
  dragging = false;
  resizing = false;
  pointerDown = false;
  resizeDir = null;
  try { canvas.releasePointerCapture(activePointerId); } catch(_){}
  activePointerId = null;
  draw();
}

canvas.addEventListener('pointerup', endPointer);
canvas.addEventListener('pointercancel', endPointer);
canvas.addEventListener('pointerout', endPointer);

/* ============================ */
btnEllas.addEventListener('click', ()=> loadDefaultMockup(DEFAULT_ELLAS));
btnEllos.addEventListener('click', ()=> loadDefaultMockup(DEFAULT_ELLOS));

mockupInput.addEventListener('change', (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    mockupImg = img;
    setCanvasSizeToImage(img);
    draw();
    URL.revokeObjectURL(url);
  };
  img.onerror = () => { alert("No se pudo cargar el mockup"); };
  img.src = url;
});

artInput.addEventListener('change', (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    artImg = img;
    const cw = canvas.width / DPR;
    art.w = cw * 0.4;
    art.h = art.w * (img.height / img.width);
    art.x = (cw - art.w) / 2;
    art.y = Math.max(60, (canvas.height/DPR)*0.25);
    draw();
    URL.revokeObjectURL(url);
  };
  img.onerror = () => alert("No se pudo cargar el diseÃ±o");
  img.src = url;
});

downloadBtn.addEventListener('click', async () => {
  draw();
  try {
    await new Promise((resolve, reject) => {
      canvas.toBlob(b=>{
        if(!b){ reject(); return; }
        const url=URL.createObjectURL(b);
        const a=document.createElement('a');
        a.href=url; a.download="camiseta_cyberpunk.png";
        a.click();
        URL.revokeObjectURL(url);
        resolve();
      });
    });
  } catch {
    try {
      const dataUrl = canvas.toDataURL("image/png");
      const a=document.createElement("a");
      a.href=dataUrl; a.download="camiseta_cyberpunk.png";
      a.click();
    } catch {
      alert("No se pudo descargar por CORS. Usa un servidor o GitHub Pages.");
    }
  }
});

resetBtn.addEventListener('click', ()=>{ 
  mockupImg = null; artImg = null;
  art = { x:100, y:150, w:300, h:300 };
  canvas.width = 800 * DPR;
  canvas.height = 1000 * DPR;
  canvas.style.width = Math.min(800, window.innerWidth - 40) + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
});

(function init(){
  canvas.width = 800 * DPR;
  canvas.height = 1000 * DPR;
  canvas.style.width = Math.min(800, window.innerWidth - 40) + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
})();
</script>
</body>
</html>
