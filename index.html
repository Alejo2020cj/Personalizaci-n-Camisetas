<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dise√±ador Cyberpunk de Camisetas</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
<style>
  :root{ --neon1:#ff00cc; --neon2:#00e5ff; --bg:#04040a; }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh;
    background:radial-gradient(circle at top left,var(--bg),#0b0b12);
    color:#fff; font-family:'Orbitron',sans-serif;
    display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px;
  }
  header{
    width:100%; text-align:center; padding:14px;
    background:linear-gradient(90deg,var(--neon1),var(--neon2));
    box-shadow:0 6px 30px rgba(0,0,0,0.4); border-radius:8px; font-size:1.2rem;
  }
  .controls{ width:100%; max-width:1000px; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; align-items:center; padding:8px; }
  .controls > * { min-width:120px; }
  button, .file-label{
    background: linear-gradient(90deg,var(--neon1),var(--neon2));
    color:#000; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700; box-shadow:0 8px 20px rgba(0,0,0,0.35);
    text-align:center;
  }
  input[type="file"]{ display:none; }
  .file-label{ display:inline-block; }
  .canvas-wrap{ width:100%; max-width:900px; display:flex; justify-content:center; align-items:center; }
  canvas{
    width:100%; height:auto; max-height:78vh; border-radius:12px;
    border:2px solid rgba(0,229,255,0.12); box-shadow:0 10px 40px rgba(0,0,0,0.6); background:#0b0b0b; touch-action:none;
  }
  .hint{ color:#cfe9ff88; font-size:0.9rem; text-align:center; max-width:900px; }
  @media (max-width:540px){ .controls > * { min-width: 48%; } .controls { gap:8px; } }
</style>
</head>
<body>
  <header>üëï Dise√±ador Cyberpunk ‚Äî Personaliza tu Camiseta</header>

  <div class="controls">
    <button id="btnEllas">üëö Ellas</button>
    <button id="btnEllos">üëï Ellos</button>

    <label class="file-label" for="mockupInput">üì§ Subir mockup</label>
    <input id="mockupInput" type="file" accept="image/*">

    <label class="file-label" for="artInput">üñºÔ∏è Subir dise√±o</label>
    <input id="artInput" type="file" accept="image/*">

    <button id="downloadBtn">‚¨áÔ∏è Descargar PNG</button>
    <button id="resetBtn">‚Ü∫ Reiniciar</button>
  </div>

  <div class="canvas-wrap"><canvas id="canvas"></canvas></div>
  <div class="hint">Toca/arrastra para mover. Arrastra cualquier borde o esquina para redimensionar. Compatible PC y m√≥vil.</div>

<script>
/* ============================
   CONFIGuraci√≥n (edita si quieres)
   ============================ */
// Base names (sin extensi√≥n) para tus mockups quemados.
// Aseg√∫rate de poner en la misma carpeta: mockup_ellas.png o .jpg, mockup_ellos.png o .jpg
const DEFAULT_ELLAS = 'mockup_ellas';
const DEFAULT_ELLOS = 'mockup_ellos';

/* ============================
   DOM & constantes
   ============================ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const btnEllas = document.getElementById('btnEllas');
const btnEllos = document.getElementById('btnEllos');
const mockupInput = document.getElementById('mockupInput');
const artInput = document.getElementById('artInput');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');

const DPR = window.devicePixelRatio || 1;
const HANDLE = 20;
const MIN_SIZE = 30;

/* ============================
   Estado de im√°genes y caja del arte
   - mockupImg: imagen base (fija)
   - artImg: imagen del dise√±o (movible)
   - art: coordenadas en sistema BITMAP (no CSS)
   ============================ */
let mockupImg = null;
let artImg = null;
let art = { x: 100, y: 150, w: 300, h: 300 };

/* interacci√≥n */
let pointerDown = false;
let activePointerId = null;
let dragging = false;
let resizing = false;
let resizeDir = null;
let dragOffset = { x: 0, y: 0 };

/* ============================
   Helpers: ajustar canvas al mockup (DPR aware)
   - mantenemos comportamiento anterior: mockup se escala al canvas
   - canvas.style.width queda responsivo
   ============================ */
function setCanvasSizeToImage(img){
  const dpr = DPR;
  canvas.width = img.width * dpr;
  canvas.height = img.height * dpr;
  // CSS width: responsivo pero limitado al ancho de ventana (mantiene proporci√≥n)
  canvas.style.width = Math.min(img.width, window.innerWidth - 40) + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

/* ============================
   Dibujado principal
   - dibuja mockup (escalado al canvas l√≥gico)
   - dibuja art sobre el mockup en coordenadas BITMAP
   - muestra borde/manejador solo mientras se interact√∫a (como pediste)
   ============================ */
function draw(){
  // limpiar
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // dibuja mockup (si existe) a tama√±o l√≥gico
  if (mockupImg) {
    ctx.drawImage(mockupImg, 0, 0, canvas.width / DPR, canvas.height / DPR);
  } else {
    // fondo neutro si no hay mockup
    ctx.fillStyle = '#0b0b0b';
    ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
  }

  // dibuja arte si existe
  if (artImg) {
    ctx.drawImage(artImg, art.x, art.y, art.w, art.h);
  }

  // borde de selecci√≥n y manejador visible solo cuando hay interacci√≥n
  if (artImg && (dragging || resizing || pointerDown)) {
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(art.x, art.y, art.w, art.h);

    // manejador (esquina inferior derecha)
    ctx.fillStyle = '#ff00cc';
    ctx.fillRect(art.x + art.w - HANDLE/2, art.y + art.h - HANDLE/2, HANDLE, HANDLE);
  }
}

/* ============================
   Coordenadas: client -> bitmap coords
   - maneja mouse y touch (pointer events)
   ============================ */
function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
  const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
  return {
    x: (clientX - rect.left) * (canvas.width / rect.width) / DPR,
    y: (clientY - rect.top)  * (canvas.height / rect.height) / DPR
  };
}

/* ============================
   Detecci√≥n: dentro del arte o zona de redimensi√≥n
   ============================ */
function isInsideArt(p){
  return p.x >= art.x && p.x <= art.x + art.w && p.y >= art.y && p.y <= art.y + art.h;
}
function getResizeDirection(p){
  const nearLeft = Math.abs(p.x - art.x) < HANDLE;
  const nearRight = Math.abs(p.x - (art.x + art.w)) < HANDLE;
  const nearTop = Math.abs(p.y - art.y) < HANDLE;
  const nearBottom = Math.abs(p.y - (art.y + art.h)) < HANDLE;
  if (nearTop && nearLeft) return 'nw';
  if (nearTop && nearRight) return 'ne';
  if (nearBottom && nearLeft) return 'sw';
  if (nearBottom && nearRight) return 'se';
  if (nearTop) return 'n';
  if (nearBottom) return 's';
  if (nearLeft) return 'w';
  if (nearRight) return 'e';
  return null;
}

/* ============================
   POINTER EVENTS (funciona PC + m√≥vil)
   - Usamos pointer events para unificar mouse/touch/pencil
   ============================ */
canvas.addEventListener('pointerdown', e => {
  e.preventDefault();
  // protecci√≥n multi-pointer: ignorar si otro pointer ya activo
  if (activePointerId !== null && activePointerId !== e.pointerId) return;
  activePointerId = e.pointerId;
  canvas.setPointerCapture(activePointerId);

  pointerDown = true;
  const pos = getPointerPos(e);
  const dir = getResizeDirection(pos);

  if (artImg && dir){
    resizing = true; resizeDir = dir;
  } else if (artImg && isInsideArt(pos)){
    dragging = true;
    dragOffset.x = pos.x - art.x;
    dragOffset.y = pos.y - art.y;
  } else {
    // toc√≥ fuera -> mantener todo false
    dragging = false; resizing = false;
  }
  draw();
});

canvas.addEventListener('pointermove', e => {
  const pos = getPointerPos(e);
  const dir = getResizeDirection(pos);
  // cursor visual
  if (dir) canvas.style.cursor = dir + '-resize';
  else if (artImg && isInsideArt(pos)) canvas.style.cursor = 'move';
  else canvas.style.cursor = 'default';

  if (!pointerDown || activePointerId !== e.pointerId) return;
  e.preventDefault();

  if (dragging){
    art.x = pos.x - dragOffset.x;
    art.y = pos.y - dragOffset.y;
  } else if (resizing){
    // redimensiona seg√∫n la direcci√≥n detectada
    const dx = pos.x - art.x;
    const dy = pos.y - art.y;
    switch (resizeDir){
      case 'n': art.h += art.y - pos.y; art.y = pos.y; break;
      case 's': art.h = dy; break;
      case 'w': art.w += art.x - pos.x; art.x = pos.x; break;
      case 'e': art.w = dx; break;
      case 'nw': art.w += art.x - pos.x; art.h += art.y - pos.y; art.x = pos.x; art.y = pos.y; break;
      case 'ne': art.w = dx; art.h += art.y - pos.y; art.y = pos.y; break;
      case 'sw': art.w += art.x - pos.x; art.x = pos.x; art.h = dy; break;
      case 'se': art.w = dx; art.h = dy; break;
    }
    if (art.w < MIN_SIZE) art.w = MIN_SIZE;
    if (art.h < MIN_SIZE) art.h = MIN_SIZE;
  }
  draw();
});

function endPointer(e){
  if (activePointerId !== e.pointerId) return;
  dragging = resizing = false; pointerDown = false; resizeDir = null;
  try { canvas.releasePointerCapture(activePointerId); } catch(e) {}
  activePointerId = null;
  // ocultamos borde al soltar (igual que antes)
  draw();
}
canvas.addEventListener('pointerup', endPointer);
canvas.addEventListener('pointercancel', endPointer);
canvas.addEventListener('pointerout', endPointer);

/* ============================
   CARGA DE MOCKUPS QUEMADOS
   - intenta png -> jpg -> jpeg
   - una vez cargado ajusta canvas y redibuja
   - mockup queda FIJO (solo se mueve el art)
   ============================ */
function loadDefaultMockup(baseName){
  const exts = ['png','jpg','jpeg'];
  let i = 0;
  function tryLoad(){
    if (i >= exts.length){
      alert('No se encontr√≥ ' + baseName + '.png/.jpg/.jpeg en la carpeta. Coloca el archivo junto a index.html');
      return;
    }
    const img = new Image();
    img.crossOrigin = 'anonymous'; // √∫til si lo sirves por http(s)
    img.onload = () => {
      mockupImg = img;
      setCanvasSizeToImage(img); // ajusta canvas al tama√±o del mockup (comportamiento anterior)
      // Si no hay artImg cargado todav√≠a, dejamos art en su tama√±o por defecto.
      // Si hay artImg, recalculamos su posici√≥n relativa para que siga funcionando.
      draw();
    };
    img.onerror = () => { i++; tryLoad(); };
    img.src = `${baseName}.${exts[i]}`;
  }
  tryLoad();
}
btnEllas.addEventListener('click', ()=> loadDefaultMockup(DEFAULT_ELLAS));
btnEllos.addEventListener('click', ()=> loadDefaultMockup(DEFAULT_ELLOS));

/* ============================
   SUBIR MOCKUP PROPIO
   - coloca la imagen y ajusta el canvas exactamente igual que el mockup quemado
   ============================ */
mockupInput.addEventListener('change', (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    mockupImg = img;
    setCanvasSizeToImage(img);
    draw();
    URL.revokeObjectURL(url);
  };
  img.onerror = () => { alert('No se pudo cargar el mockup.'); URL.revokeObjectURL(url); };
  img.src = url;
});

/* ============================
   SUBIR ARTE / DISE√ëO (usuario)
   - redimensiona el arte al 40% del ancho l√≥gico del canvas (igual que antes)
   - centra horizontalmente
   ============================ */
artInput.addEventListener('change', (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    artImg = img;
    // ancho l√≥gico del canvas (no DPR-scaled)
    const cw = canvas.width / DPR;
    art.w = cw * 0.4;
    art.h = art.w * (img.height / img.width);
    art.x = (cw - art.w) / 2;
    // si quieres una altura fija sobre el pecho, mantenemos y=200 (como antes)
    art.y = Math.max(60, (canvas.height / DPR) * 0.25);
    draw();
    URL.revokeObjectURL(url);
  };
  img.onerror = () => { alert('No se pudo cargar el dise√±o.'); URL.revokeObjectURL(url); };
  img.src = url;
});

/* ============================
   DESCARGA ROBUSTA (toBlob con fallback)
   ============================ */
downloadBtn.addEventListener('click', async () => {
  draw();
  try {
    await new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (!blob) { reject(new Error('toBlob returned null')); return; }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'camiseta_cyberpunk.png';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
        resolve();
      }, 'image/png');
    });
    return;
  } catch (err) {
    console.warn('toBlob fall√≥:', err);
  }
  // fallback toDataURL (podr√≠a fallar si canvas est√° tainted)
  try {
    const dataUrl = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataUrl; a.download = 'camiseta_cyberpunk.png';
    document.body.appendChild(a); a.click(); a.remove();
    return;
  } catch (err) {
    console.error('toDataURL fall√≥ (canvas probablemente tainted):', err);
    alert(
      'No se pudo descargar la imagen. Suele pasar por CORS si las im√°genes no se sirven desde un servidor.\n\n' +
      'Soluciones:\n' +
      '‚Ä¢ Usa Live Server / python -m http.server o sube a GitHub Pages.\n' +
      '‚Ä¢ Aseg√∫rate de que los mockups quemados est√©n en el mismo repo y ruta.'
    );
  }
});

/* ============================
   REINICIO
   ============================ */
resetBtn.addEventListener('click', ()=> {
  mockupImg = null; artImg = null;
  art = { x:100, y:150, w:300, h:300 };
  const dpr = DPR;
  canvas.width = 800 * dpr; canvas.height = 1000 * dpr;
  canvas.style.width = Math.min(800, window.innerWidth - 40) + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
});

/* ============================
   INICIALIZACI√ìN: tama√±o por defecto
   ============================ */
(function init(){
  const dpr = DPR;
  canvas.width = 800 * dpr;
  canvas.height = 1000 * dpr;
  canvas.style.width = Math.min(800, window.innerWidth - 40) + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
})();
</script>
</body>
</html>
